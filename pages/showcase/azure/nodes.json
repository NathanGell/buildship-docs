[
  {
    "output": {
      "buildship": { "index": 0 },
      "description": "",
      "title": "Assistant Response",
      "type": "object",
      "properties": {
        "threadId": {
          "buildship": { "index": 1 },
          "description": "The thread ID that this message belongs to.",
          "title": "Thread ID",
          "type": "string"
        },
        "response": { "buildship": { "index": 2 }, "description": "", "title": "Response", "type": "string" },
        "annotations": {
          "buildship": { "index": 3 },
          "description": "The annotations of the message",
          "title": "Annotations",
          "type": "array"
        },
        "messages": {
          "buildship": { "index": 0 },
          "description": "The content of the message in array of text and/or images.",
          "title": "Messages",
          "type": "array"
        }
      }
    },
    "inputs": {
      "type": "object",
      "required": ["resource", "assistantId", "azureApiKey", "userPrompt"],
      "properties": {
        "threadId": {
          "buildship": { "index": 2 },
          "description": "The ID of the conversation thread to use. If not specified, a new thread will be created.",
          "title": "Thread ID",
          "type": "string"
        },
        "assistantId": {
          "buildship": { "index": 1, "sensitive": false },
          "pattern": "",
          "description": "The ID of the assistant to use. You need to create the assistant in the Azure OpenAI Studio.",
          "title": "Assistant ID",
          "type": "string"
        },
        "instructions": {
          "buildship": { "index": 5 },
          "description": "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.",
          "title": "Instructions",
          "type": "string"
        },
        "builtInTools": {
          "buildship": {
            "options": [
              { "label": "Document Retrieval", "value": "retrieval" },
              { "label": "Code Interpreter", "value": "code_interpreter" }
            ],
            "index": 6
          },
          "description": "Select the OpenAI assistant built-in tools to use.",
          "title": "Built-in Tools",
          "type": "array",
          "enum": ["retrieval", "code_interpreter"]
        },
        "resource": {
          "buildship": { "hidden": false, "index": 4, "sensitive": false },
          "pattern": "",
          "description": "The name of your Azure resource.",
          "title": "Resource",
          "type": "string"
        },
        "userPrompt": {
          "default": "",
          "buildship": { "index": 6, "sensitive": false },
          "pattern": "",
          "description": "The prompt to send to the assistant as user message.\n",
          "title": "User Prompt",
          "type": "string"
        },
        "azureApiKey": {
          "buildship": { "index": 0, "sensitive": false },
          "pattern": "",
          "description": "The Azure API key to use for authentication.",
          "title": "API Key",
          "type": "string"
        }
      }
    },
    "meta": {
      "name": "Azure OpenAI Assistant",
      "icon": { "type": "URL", "url": "https://www.svgrepo.com/show/448274/azure.svg" },
      "description": "Add different tools or script nodes for function calling and let the Azure OpenAI assistant automatically choose which to execute based on the input.",
      "id": "azure-openai-assistant-node"
    },
    "subType": "assistant",
    "_createdBy": {
      "displayName": "Save to Library",
      "timestamp": { "_seconds": 1714628710, "_nanoseconds": 654000000 }
    },
    "type": "script",
    "integrations": [],
    "dependencies": {
      "timers": "0.1.1",
      "@azure/openai-assistants": "1.0.0-alpha.20240501.1",
      "@azure/openai": "1.0.0-alpha.20240501.1"
    },
    "featured": true,
    "live": true,
    "deployToBucket": {
      "ranBy": "harini@rowy.io.rowy",
      "completedAt": { "_seconds": 1714628760, "_nanoseconds": 843000000 }
    },
    "failCount": 13,
    "integrity": "v3:ff8d4cbd13380f36c948fd6dd4087a23",
    "src": "https://storage.googleapis.com/buildship-app-us-central1/publicLib/nodes/@buildship/azure-openai-assistant-node/1.1.0/build.cjs",
    "id": "azure-openai-assistant-node",
    "version": "1.1.0",
    "_libRef": {
      "integrity": "v3:6e5d78ce6f9fd6e9d8b23fec72c98aa5",
      "libNodeRefId": "@buildship/azure-openai-assistant-node",
      "isDirty": false,
      "libType": "public",
      "src": "https://storage.googleapis.com/buildship-app-us-central1/publicLib/nodes/@buildship/azure-openai-assistant-node/1.0.1/build.cjs",
      "version": "1.0.1"
    },
    "script": "import { AssistantsClient, ToolDefinition } from \"@azure/openai-assistants\";\nimport { AzureKeyCredential } from \"@azure/openai\";\nimport { setTimeout } from \"timers/promises\";\n\nconst nodeToOpenAiFunction: (node: Node) => ToolDefinition = (node) => {\n  return {\n    type: \"function\",\n    function: {\n      name: node.id,\n      description: node.meta.description ?? \"\",\n      parameters: {\n        type: \"object\",\n        properties: Object.entries(node.inputs.properties)\n          .reduce((properties, [name, value]) => {\n            if (value.buildship && !value.buildship.toBeAutoFilled) return properties;\n            return {\n              ...properties, [name]: {\n                type: value.type,\n                enum: value.enum,\n                description: value.description\n              }\n            }\n          }, {}),\n        required: Object.entries(node.inputs.properties).map(([name, value]) => {\n          if (value.buildship && value.buildship.toBeAutoFilled && node.inputs.required.includes(name)) return name;\n          return false;\n        }).filter(Boolean),\n      }\n    }\n  };\n}\n\nconst sleep: (ms: number) => Promise<any> = (ms) =>\n  new Promise((resolve) => setTimeout(ms).then(() => resolve(true)));\n\ntype Params = {\n  azureApiKey: string;\n  resource: string;\n  assistantId: string;\n  threadId: string;\n  userPrompt: string;\n  builtInTools: string[];\n  instructions: any;\n}\n\nexport default async function assistant(\n  { azureApiKey, resource, assistantId, threadId, userPrompt, builtInTools = [], instructions }: NodeInputs,\n  { logging, execute, nodes }: NodeScriptOptions) : NodeOutput  {\n\n  const tools = nodes?.map(nodeToOpenAiFunction) ?? [];\n\n  const endpoint = `https://${resource}.openai.azure.com`;\n  const credentials = new AzureKeyCredential(azureApiKey);\n  const assistantsClient = new AssistantsClient(endpoint, credentials);\n\n  const messages = [{ role: \"user\", content: userPrompt }];\n\n  if (threadId) {\n    await assistantsClient.createMessage(threadId, \"user\", userPrompt);\n  } else {\n    threadId = (await assistantsClient.createThread({ messages })).id;\n    logging.log(\"New thread created with ID:\", threadId);\n  }\n\n  // Retrieval tool isn't supported in Azure yet\n  // builtInTools.includes(\"retrieval\") && tools.push({ type: \"retrieval\" });\n  builtInTools.includes(\"code_interpreter\") && tools.push({ type: \"code_interpreter\" });\n\n  let runResponse = await assistantsClient.createRun(threadId, {\n    assistantId,\n    instructions,\n    tools,\n  });\n\n  do {\n    await sleep(1000);\n    runResponse = await assistantsClient.getRun(runResponse.threadId, runResponse.id);\n\n    const isToolUse = runResponse.status === \"requires_action\" && runResponse.requiredAction?.type === \"submit_tool_outputs\";\n    if (isToolUse) {\n      const toolOutputs = [];\n      const toolUses = runResponse.requiredAction?.submitToolOutputs?.toolCalls || [];\n      for (const toolUse of toolUses) {\n        let args;\n        try {\n          args = JSON.parse(toolUse.function.arguments);\n          logging.log(args);\n        } catch (err) {\n          logging.log(`Couldn't parse function arguments. Received: ${toolUse.function.arguments}`);\n          throw new Error(`Couldn't parse function arguments. Received: ${toolUse.function.arguments}`)\n        }\n        const node = nodes?.find((node: Node) => node.id === toolUse.function.name);\n        if (!node) {\n          throw new Error(`Unknown tool: ${toolUse.function.name}`);\n        }\n        // filter hallucinated inputs\n        const inputs = {} as Record<string, unknown>;\n        for (const [inputKey, inputValue] of Object.entries(args)) {\n          if (node.inputs.properties[inputKey]) {\n            inputs[inputKey] = inputValue;\n          }\n        }\n        const toolOutput = await execute(node.label, inputs);\n\n        logging.log(toolOutput);\n        toolOutputs.push({\n          toolCallId: toolUse.id,\n          output: toolOutput ? JSON.stringify(toolOutput) : \"\"\n        });\n        logging.log(\n          `Executed ${node.label} with output:`,\n          toolOutput\n        );\n      }\n      runResponse = await assistantsClient.submitToolOutputsToRun(runResponse.threadId, runResponse.id, toolOutputs);\n    }\n  } while (runResponse.status === \"queued\" || runResponse.status === \"in_progress\")\n\n  const { data } = await assistantsClient.listMessages(runResponse.threadId, { order: \"desc\" });\n\n  const resultMessage = data[0];\n\n  if (resultMessage.content[0].type === \"text\") {\n    return {\n      \"response\": resultMessage.content[0].text.value,\n      \"annotations\": resultMessage.content[0].text.annotations,\n      \"threadId\": runResponse.threadId,\n      \"messages\": data\n    };\n  }\n\n  if (resultMessage.content[0].type === \"image_file\") {\n    return {\n      \"response\": \"\",\n      \"imageFileId\": resultMessage.content[0].imageFile.fileId,\n      \"annotations\": [],\n      \"threadId\": runResponse.threadId,\n      \"messages\": data\n    };\n  }\n}\n\ntype Node = {\n  label: string;\n  meta: {\n    id: string;\n    description: string;\n    name: string;\n    [key: string]: any;\n  };\n  inputs: {\n    type: string;\n    required: string[];\n    properties: Record<string, {\n      description: string;\n      buildship?: {\n        toBeAutoFilled?: boolean;\n        [key: string]: any;\n      }\n      [key: string]: any;\n    }>;\n  };\n  [key: string]: any;\n};",
    "group": [
      {
        "uid": "azure",
        "name": "Azure",
        "description": "Nodes for leveraging the AI Models by Microsoft Azure.",
        "id": "azure",
        "iconUrl": "https://firebasestorage.googleapis.com/v0/b/website-a1s39m.appspot.com/o/buildship-app-logos%2FMicrosoft_Azure.png?alt=media&token=bbf33371-e12c-44e4-9f8a-2db1ba0ff1a6"
      }
    ],
    "groupInfo": "azure",
    "category": ["Integrations"],
    "_updatedBy": {
      "uid": "Nb5Sn267f6eOTgqnlB1d6Hxi5VR2",
      "emailVerified": true,
      "photoURL": "https://lh3.googleusercontent.com/a-/AFdZucpItz8EJNSW_ttNzT-N4cG9IQVT5Ipuvbq7xx5Z=s96-c",
      "updatedField": "syncIndex",
      "displayName": "Bhavya Verma",
      "email": "bhavya@rowy.io.rowy",
      "timestamp": { "_seconds": 1716930679, "_nanoseconds": 474000000 }
    },
    "syncIndex": {
      "ranBy": "bhavya@rowy.io.rowy",
      "status": "synced",
      "completedAt": { "_seconds": 1716930679, "_nanoseconds": 489000000 }
    },
    "usageCounter": 69,
    "deployedAt": { "_seconds": 1717467670, "_nanoseconds": 39000000 }
  }
]
