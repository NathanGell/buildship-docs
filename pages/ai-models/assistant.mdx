---
title: OpenAI Assistant integration
description: Our OpenAI integration allows you to
---

import Image from 'next/image';
import { Callout } from 'nextra/components';

# Assistant Guide

## Introduction

Since the launch of GPTs, we have seen a lot of new custom AI agents that can be used within ChatGPT to help people in
their daily life, at specific tasks, at work, or at home.

Most of these AI agents live in the ChatGPT interface and are only available for paid users within OpenAI. To open the
access to these GPTs, at [OpenAI Dev Day](https://www.youtube.com/watch?v=U9mJuUkhUzk), the company introduced
[OpenAI Assistant API](https://platform.openai.com/docs/assistants/overview) which included new capabilities to build
custom AI assistants.

![GPTs, your own version of ChatGPT customised to fill a purpose  - from OpenAI [announcement](https://openai.com/blog/introducing-gpts)  ](./assistant-src/Untitled.png)

In BuildShip, we introduce the OpenAI Assistant Integration to bring all these capabilities to your applications helping
you without writing a line of code. In this article we’ll cover up the following topics:

- Create an Assistant
- Connect your Assistants to BuildShip
- Memory & conversation: building a Quiz Tutor
- Tool usage: teach your assistants to use tools to do tasks for you like sending emails or updating your databases

<Callout emoji='🚀'>
  You can follow [OpenAI Assistant Guide](https://platform.openai.com/playground?assistant=new), and build your own
  Assistant.
</Callout>

## Create an Assistant

An Assistant follows up custom instructions and can leverage models, tools and knowledge to respond to user messages. In
this example, we are creating an Assistant that’s a personal history tutor that engages with people by asking questions.

The main parameters to consider are:

- **Name & assistant ID**: you can name your assistants. When saving, an assistant ID will be autogenerated and shown to
  you below that
- **Instructions**: how the Assistant should behave and respond
- **Model**: the GPT version you want to use
- **Tools**: using Code Interpreter for running code or Retrieval to update files
- **Functions**: to define custom behaviors, you’ll learn how we’ll use our BuildShip nodes as tools for our assistants

Now let’s learn how we can access Assistants outside the context of OpenAI using BuildShip.

## Connect your Assistant to BuildShip

From Template view, you can search for `Basic Assistant` template that will create a basic workflow structure for you.
If you already have a workflow you can also search `OpenAI Assistant`in the Node Explorer.

In both cases, you have will have to fill up your _Open AI API Key_ and the _Assistant ID_ to easily connect it. You can
also update your _Instructions_ from here or already use what you defined.

![example_assistant.gif](./assistant-src/example_assistant.gif)

<Callout emoji='☝'>
  If you leave Instructions field empty, have to **will consider what you have already defined** in OpenAI playground.

 </Callout>

After that, you can test it out via a message like _Who was Leonardo da Vinci?_ Remember you can use variables to easily
change the inputs for your nodes.

We assume passing the prompt as a parameter in the POST request:

```json
{ "message": "Who was Leonardo da Vinci?" }
```

![message post.gif](./assistant-src/message_post.gif)

We can now access Assistant response via the parameter _response_ which returns its last message (you’ll probably get a
message similar to the following)

```json
{
  "response": "Leonardo da Vinci was a Renaissance polymath active mainly in Italy from the
  late 15th to the early 16th century.
  Quiz Question: Which of the following is NOT a work of Leonardo da Vinci?
  A) Vitruvian Man
  B) The School of Athens
  C) Lady with an Ermine
  D) Ginevra de' Benci",

  "threadID": "thread_KHdD6NGPwx0yY6mIkj0UgMPe"
}
```

Notice how each time you run your workflow, a new conversation will be started and you’ll get an answer from your
Assistant.

Lets now explore the output from OpenAI assistant node. We can access also to the following parameters:

- **Messages**: a list of all the messages from the conversation
- **ThreadID**: unique id of the current conversation
  ![parameters.gif](./assistant-src/parameters.gif)

In the following section, you’ll learn how to use _Thread ID_ to save and continue conversations.

## Memory & conversation

When you start chatting with an Assistant, a _Thread_ is created representing this conversation. We recommend saving
them as soon the conversation is initiated. You can use BuildShip internal database to do that. We provide two basic
templates on Saving a Thread ID and access to our historic of threads. For now, let’s just copy the thread id,

For now, let’s assume that we copy the thread ID from the first message and we include it in our request. Our new
message is the answer of the past quiz and the previous threadID

```json
{ "message": "The School Of Atens", "threadID": "your_thread_id" }
```

And it works! We can see from the Assistant’s response that we correctly answered and the conversation continues.

```json
{
"response": "Correct! *The School of Athens* is not a work by Leonardo da Vinci. It was actually painted by Raphael,
another master of the Renaissance.",
"threadID": "thread_KHdD6NGPwx0yY6mIkj0UgMPe"
}
```

Now it’s your turn, you can download the template Chat with Assistant as an example to start. Modify the Instructions
and your messages and see how the Assistant behaves.

You can test it directly from BuildShip Test button or you can Deploy it and call your endpoint from your preferred
environment.

## Tool usage (I): teach the assistant to access your database

We have learn how to access and follow-up conversations with Assistants within BuildShip. Now let’s explore how we can
teach these AI agents to use tools to perform the tasks they are required. This can include connecting to different
services and products such as Gmail, Discord messaging, Notion API or Supabase amongst others.

Using BuildShip we can simply provide this extra capabilities to these agents by adding nodes to the assistant and
modifying the original instructions to support that.

In this example, we’ll follow up with the Tutor Assistant scenario to allow it to save all the quizzes generated to a
database. As illustrated below, the idea is to have a conversation with the assistant and let it handle creating a
database for you.

![A tiny chat interface to interact with Quiz Master ](./assistant-src/QuizAttack.gif)

<Callout type='info'>
  A prerequisite for this template is to create a database with a collection named ‘Quiz’ in your project. Learn more on
  [Buildship Databases](https://docs.buildship.com/basics/buildship-tables )
</Callout>

We are gonna use the following structure to save each generated quiz:

- **question**: the specific quiz question presented to the user
- **options**: a list of 4 options to choose from
- **correctAnswer:** the answer to the question
- **keywords**: autogenerated keywords for later organising the questions

Below example on how your database would look like after interacting with Quiz Master 👇

![An example on how your database would look like after interacting with Quiz Master](./assistant-src/db-example.png)

You are all set. Now it’s time to teach our Assistant to use tools to fill this database. To do that, we must assume two
main aspects:

- You have to properly **describe the given tools**, together with its parameters. E.g: Send email: This function calls
  Gmail API and send an email
- You have to specify **the desired action** on your request. E.g: send a happy NY greeting to my contacts

Let’s see how to do it with our Quiz master.

### Step 1. Add nodes and describe them

First of all, we’ll add the Create Document from Buildship Database.

![Add Node.gif](./assistant-src/Add_Node.gif)

As you will see, you can add any nodes you want and teach the Assistant how to use them. The most important aspect to
consider is to provide proper descriptions on what this nodes should do.

In our example, we’ll update both the name and the description of the node:

<Callout type='warning'>
  **Original Name** → Create document <br />
  **Original Description** → Creates or updates a document in a specified Firestore collection
</Callout>

**New Name**: ` updateDatabase`

**New Description**:

```
Save quiz data to a database. It should be JSON format:
{"question":"", "options":[list],"correctAnswer":"", "keywords":[list]}
```

Note how we also provide information on how we are gonna handle the data within the description of the node. This is
because when using Assistant with tools, all the node information is also considered to answer a user message. Based on
this information, together with the _Instructions_ and _user prompt_ the assistant will decide how to answer.

Internally, we are describing our nodes as
[functions](https://platform.openai.com/docs/assistants/tools/function-calling) that Assistant will intelligently decide
to use. We are not adding any extra prompting on user requests, so everything you describe is what the assistant is
gonna use to decide.

Once you have described the node, you are gonna decide which inputs you provide and which ones the Assistant will be
responsible to fill in. Let’s see how to do that 👇

### Step 2. Decide which inputs will be auto-filled

Assistant can intelligently fill the inputs from your tools. To do that, you must consider which context and accessible
information is available for it.

You are responsible to fill in inputs related to information you are not sending to OpenAI. For example your secret Keys
or labels from your internal database. In addition we also recommend filling the inputs we know they are not gonna
change. For example, if you want to always send an email from a certain address it’s better to define it yourself.

All the information you fill will not be visible, neither modified by the Assistant. As an example, in our Quiz Master
we already provide information about the Collection name ‘Quiz’ and we leave all the other default values.

To tell the Assistant to fill an input we must enable it by pressing the icon next to it.

![fill.gif](./assistant-src/fill.gif)

Then, as before, it’s better to provide context about how this input will be filled. Providing context on what is this
input, how it is used or which is its expected format will guide the Assistant to correctly provide this information

<Callout type='warning'>
  **Input Name** → Data <br />
  **Input Description** → The data to set in the document
</Callout>

**New Name**: ` Quiz data`

**New Description**:

```
Save quiz data to a database. It should be JSON format:
{"question":"", "options":[list],"correctAnswer":"", "keywords":[list]}
```

Your node is ready to be used by the Assistant, now we only need to update it in our instructions.

### Step 3. Modify the instructions

Finally, let’s update our instructions. It’s important to imagine the possible scenarios when using the Assistant. For
example, you can decide if you want to ask first to the user on the topic of the quiz or you can decide it yourself. As
en example, this is the instructions we use.

```json
{
  "instructions": "You are a personal history tutor. You will answer questions in a concise way. If no question is given, you should provide a historical fact. You must also engage with users by creating little quizzes with 4 possible options to answer in each question. Then, you must the 'updateDatabase' tool to save the latest quiz to the database."
}
```

First of all, we provide context on what’s the task to accomplish together with some guidance on how to act when user
doesn’t ask anything. Then we describe the actions to be done: first generate the quiz with options and then save it to
the database with the newly defined tool ‘updateDatabase’

Ready! You can now test out your new Assistant. Once you test it, note how we inform you that the tool has been used via
the Green Run icon.

![quiz roman .gif](./assistant-src/quiz_roman_.gif)

You have learnt a basic example on how to use BuildShip nodes with the Assistant. Let’s now learn how to combine using
nodes and workflows together with the Assistant.

## Tool usage (II): your AI marketer, generate and send emails

Using BuildShip we can also teach our Assistants to use workflows as tools. In this example, we are gonna build an
Assistant that generates responses and sends emails to your contacts. To do that you can download the Mail Assistant
template.

<Callout type='info'>
  A prerequisite for this tutorial is to create a collection within BuildShip named contacts and a basic workflow to
  access it.
</Callout>

You can copy the code below and paste it in a new workflow.

````json
{
  "nodes": [
    {
      "inputs": {
        "required": ["collection", "filters"],
        "properties": {
          "orderBy": {
            "pattern": "",
            "buildship": { "index": 3, "sensitive": false },
            "type": "array",
            "description": "Order results in desc or asc order.\nEg: `[{fieldName: \"asc\"}]` or `[{fieldName: \"desc\"}]`",
            "title": "Order By"
          },
          "collection": {
            "buildship": { "index": 0 },
            "title": "Collection Name",
            "type": "string",
            "description": "The name of the BuildShip collection"
          },
          "filters": {
            "pattern": "",
            "type": "array",
            "description": "The array of filter objects, each object includes {field, operator, value}[]\n\nSAMPLE INPUT: \n```\n[{\"field\":\"Name\",\"operator\":\"==\",\"value\":\"Alice\"}]\n```",
            "default": [{ "field": "", "value": "", "operator": "" }],
            "title": "Filters",
            "buildship": { "index": 1, "sensitive": false }
          },
          "limit": {
            "buildship": { "index": 2 },
            "description": "Maximum number of returned documents",
            "type": "number",
            "title": "Limit",
            "default": ""
          }
        },
        "type": "object"
      },
      "meta": {
        "icon": {
          "url": "https://firebasestorage.googleapis.com/v0/b/website-a1s39m.appspot.com/o/buildship-app-logos%2FIcon.png?alt=media&token=878ed11b-1cf2-45d8-9951-7e95a16d26af&_gl=1*1ld9l67*_ga*NzgyMDk5NjMxLjE2OTY4NzE3ODU.*_ga_CW55HF8NVT*MTY5NjkyMzc5OC4yLjEuMTY5NjkyMzgzMy4yNS4wLjA.",
          "type": "URL"
        },
        "id": "buildship-firestore-collection-query",
        "name": "Collection Query",
        "description": "Get documents of a query in Firestore with multiple filters\n\n<video src='http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4' width=180/>\n"
      },
      "description": "Get documents of a query in Firestore with multiple filters",
      "label": "Collection Query",
      "integrity": "19ce3941be33d8272186fea43546e2fc73c2d5a8559deb4f8e3fec3c0242d92b",
      "type": "script",
      "dependencies": { "@google-cloud/firestore": "7.1.0" },
      "output": {
        "description": "The array of documents that match the query",
        "properties": {
          "data": { "type": "object", "title": "Document Data", "buildship": { "index": 1 } },
          "id": { "buildship": { "index": 0 }, "type": "string", "title": "Document ID" }
        },
        "type": "array",
        "buildship": {},
        "title": "Documents"
      },
      "onFail": null,
      "id": "81165841-47ed-4646-8097-b6f57d6b8578",
      "script": "import { Firestore } from '@google-cloud/firestore';\n\nexport default async function firestoreQueryDocuments(\n  {\n    collection,\n    filters = [],\n    limit,\n    orderBy = [],\n  },\n  {}\n) {\n  const firestore = new Firestore(undefined);\n\n  let query = firestore.collection(collection);\n\n  orderBy.forEach(orderObj => {\n    for (const [field, direction] of Object.entries(orderObj)) {\n      const lowerCaseDirection = direction.toLowerCase();\n      if (lowerCaseDirection === 'asc' || lowerCaseDirection === 'desc')\n        query = query.orderBy(field, lowerCaseDirection);\n    }\n  });\n\n  // Validate that filters exist and each filter has necessary properties\n  if (Array.isArray(filters)) {\n    filters.forEach(filter => {\n      if (filter.field && filter.operator && filter.hasOwnProperty('value')) {\n        query = query.where(filter.field, filter.operator, filter.value);\n      }\n    });\n  }\n\n  let snapshot = await query.limit(limit ?? 100).get();\n  return snapshot.docs.map(doc => ({\n    id: doc.id,\n    data: doc.data()\n  }));\n}\n",
      "bsTablePopup": true,
      "version": "1.0.1",
      "src": "https://storage.googleapis.com/buildship-app-us-central1/builtNodes/buildship-firestore-collection-query/1.0.1.cjs"
    },
    {
      "label": "Return",
      "type": "return",
      "response": { "200": { "type": "object", "buildship": {}, "title": "Document Data" } },
      "description": "The Return Node is used to return values from the workflow. It is generally the last node in the workflow. The return node is optional as the API can inherently return a 200 OK response by default. [Full Documentation](https://docs.buildship.com/core-nodes/return).",
      "id": "2e0571db-4c98-4bd5-bf2e-08118a0b4893",
      "inputs": {
        "required": [],
        "type": "object",
        "properties": {
          "status": {
            "default": "200",
            "enum": ["200", "201", "202", "204", "400", "401", "403", "404", "500"],
            "buildship": {
              "index": 0,
              "options": [
                { "label": "OK (200)", "value": "200" },
                { "value": "201", "label": "Created (201)" },
                { "label": "Accepted (202)", "value": "202" },
                { "label": "Redirect (301)", "value": "301" },
                { "label": "No Content (204)", "value": "204" },
                { "label": "Bad Request (400)", "value": "400" },
                { "value": "401", "label": "Unauthorized (401)" },
                { "value": "403", "label": "Forbidden (403)" },
                { "value": "404", "label": "Not Found (404)" },
                { "value": "500", "label": "Internal Server Error (500)" }
              ]
            },
            "type": "string",
            "description": "The HTTP status code to return",
            "title": "Status code"
          },
          "cacheMaxAge": {
            "type": "number",
            "buildship": { "index": 2 },
            "title": "Cache Time",
            "default": 0,
            "description": "Set cache duration"
          },
          "value": {
            "default": "",
            "title": "Value",
            "buildship": { "index": 1 },
            "description": "The value to return",
            "type": "string"
          }
        }
      }
    }
  ],
  "trigger": {
    "inputs": {
      "required": [null],
      "properties": {
        "serviceAccount": {
          "pattern": "",
          "title": "Service Account",
          "description": "**(OPTIONAL)** If you're calling this workflow from a different BuildShip Project, you need to specify the **Runtime Service Account** of other project here. \n\nYou can get the BuildShip Runtime Service Account from your Project Settings.",
          "buildship": { "sensitive": false, "index": 0 },
          "default": "",
          "type": "string"
        }
      },
      "type": "object"
    },
    "id": "x-buildship-trigger",
    "label": "BuildShip Trigger",
    "meta": {
      "icon": {
        "type": "URL",
        "url": "https://firebasestorage.googleapis.com/v0/b/website-a1s39m.appspot.com/o/buildship-app-logos%2Fbuildship.png?alt=media&token=c5248170-8cb1-4a66-af37-436c7a2aa6b8"
      },
      "id": "x-buildship-trigger",
      "name": "BuildShip Trigger",
      "description": "Trigger a workflow from any BuildShip Workflow via the \"**Execute Workflow**\" node. [Full documentation](https://docs.buildship.com/trigger-nodes/buildship-trigger)"
    },
    "output": {
      "title": "Data",
      "parameters": [],
      "buildship": {},
      "type": "object",
      "description": "Request Data",
      "label": "Body",
      "properties": {}
    },
    "type": "webhook",
    "script": "import { OAuth2Client } from \"google-auth-library\";\n\nconst onCreate = async ({ _ }, { workflow, runtimeUrl }) => {\n  return { success: true };\n};\n\nconst onExecution = async ({ serviceAccount }, { workflow, req, logging }) => {\n\n  const idToken = req.request.headers.authorization?.split(\"Bearer \")[1];\n  logging.log({ idToken });\n\n  if (idToken === undefined) {\n    req.throw(`Missing authorization header`);\n  }\n\n  try {\n    // Ensure that token is valid and not expired\n    const oAuth2client = new OAuth2Client();\n    const ticket = await oAuth2client.verifyIdToken({\n      idToken,\n      audience: `${process.env.GCLOUD_PROJECT}-${workflow.id}`\n    });\n\n    // Extract payload from token\n    const payload = ticket.getPayload();\n    if (payload === undefined) {\n      req.throw(\"Invalid token\");\n    }\n    const expectedServiceAccount = serviceAccount || `runtime@${process.env.GCLOUD_PROJECT}.iam.gserviceaccount.com`\n    if (payload.email !== expectedServiceAccount) {\n      req.throw(`Wrong service account, got ${payload.email}, expected ${expectedServiceAccount}`);\n    }\n\n    // Ensure that the token issuer is https://accounts.google.com or accounts.google.com\n    if (\n      payload.iss !== \"https://accounts.google.com\" &&\n      payload.iss !== \"accounts.google.com\"\n    ) {\n      req.throw(\"Wrong issuer\");\n    }\n\n  logging.log(`Verified request, body: `, req.request.body)\n  return req.request.body;\n  }\n  catch (e){\n    return e\n  }\n};\nexport default {\n  onCreate,\n  onUpdate: onCreate,\n  onExecution\n};\n",
    "icon": {
      "type": "URL",
      "url": "https://firebasestorage.googleapis.com/v0/b/website-a1s39m.appspot.com/o/buildship-app-logos%2Fbuildship.png?alt=media&token=c5248170-8cb1-4a66-af37-436c7a2aa6b8"
    },
    "live": true,
    "instruction": {
      "bodyTemplate": "{\n  projectId: \"{{projectId}}\",\n  workflowId: \"{{workflowId}}\"\n}",
      "title": "Configuration for \"Execute Workflow\" node"
    }
  },
  "nodeValues": {
    "43fe208b-9b48-47cc-bb38-9b562700083a": {
      "filters": { "expression": "[]" },
      "collection": "contacts",
      "limit": 20
    },
    "81165841-47ed-4646-8097-b6f57d6b8578": {
      "collection": "contacts",
      "limit": 20,
      "orderBy": { "expression": "\"\"" },
      "filters": { "expression": "[]" }
    },
    "mock-id": { "cacheMaxAge": 0, "status": "200", "value": "" },
    "test-node-81165841-47ed-4646-8097-b6f57d6b8578": {
      "orderBy": "",
      "limit": 20,
      "filters": [{ "field": "", "value": "", "operator": "" }],
      "collection": "contacts"
    },
    "http": { "method": "GET", "path": "/" },
    "e38db03c-eabf-45da-8576-cffe316ce3db": {
      "limit": 20,
      "collection": "contacts",
      "filters": { "expression": "[]" }
    },
    "x-buildship-trigger": { "serviceAccount": "" },
    "2e0571db-4c98-4bd5-bf2e-08118a0b4893": {
      "status": "200",
      "cacheMaxAge": 0,
      "value": { "keys": ["81165841-47ed-4646-8097-b6f57d6b8578", "data"] }
    }
  },
  "notes": ""
}
````

Make sure that your collection has the fields name and email set.

![Untitled](./assistant-src/Untitled%202.png)

### Step 1. Create the Assistant

Let’s start by giving the task and the context to the assistant. We are also describing the tools its gonna use and some
extra information on how to handle if users refers to themselves

```json
**INSTRUCTIONS**: You are specialized on sending emails with a concise response given a context. Users will describe the message they want to send and the expected recipient. You must use 'get contacts' to look for your contacts and then use 'Send Email' to the required contact. Consider that if the user says myself or me you should use sender email
```

### Step 2. Add the nodes and describe them

Let’s now add Send Email tool. In this scenario, note how all the inputs except from the sender email will be
auto-filled by the AI.

![Untitled](./assistant-src/Untitled%203.png)

Then, we add the node _Execute Workflow_ to the Assistant and we update its name and description. Then we provide the
respective workflow ID to be called (more in our [guide](https://docs.buildship.com/trigger-nodes/buildship-trigger))

<Callout type='warning'>
  **Name** → Execute Workflow <br />
  **Description** → Executes a BuildShip Workflow using the `BuildShip Trigger` on the target workflow.
</Callout>

<Callout type='info' emoji='✨'>
  **Name** → get contacts <br />
  **Description** → a function to access contacts and return a list of emails
</Callout>

In this case, we don’t tell the Assistant to fill any information, since we expect this workflow to

return us the list of users.

### Step 3. Test it out

We are all set! If we test this workflow and we ask to reach out a contact from our database we can check in our Gmail
account that a new message will be send correctly!

![Untitled](./assistant-src/Untitled%204.png)

![Untitled](./assistant-src/Untitled%205.png)

You can explore different instructions to guide the Assistant how to respond. As a simple example, you can tell the
Assistant how to sign the message.

```json
**INSTRUCTIONS**: You are specialized on sending emails with a concise response given a context. Users will describe the message they want to send and the expected recipient. You must use 'get contacts' to look for your contacts and then use 'Send Email' to the required contact. Consider that if the user says myself or me you should use sender email

Your signature should be always: AI curated message from Mail Assistant
```

![Untitled](./assistant-src/Untitled%206.png)

Remember that providing good context and instructions is relevant when talking with AI agents and asking them to perform
tasks.

## Conclusion

We hope that this guide help you better understand how to use and integrate Assistants to our own workflows. We imagine
that combining Assistants together with BuildShip you can explore many interesting scenarios:

- Custom chats: use AI capabilities to create a chat in your own product.
- Chat with your data : create assistants that access your knowledge to respond
- Seamless integration with your apps: make them use your tools like Gmail, Supabase, etc
- Teams of AI agents: divide tasks into multiple assistants and make them handle

As you will see, making them to use tools requires a good tool’s description and detailed instructions. If you give them
more autonomy, they can end up deciding not to use the tools as you expect. To succeed, we provide a set of guidelines
on defining instructions based on our explorations:

- Use the name of the tool. _E.g: use 'Send email' tool_
- Don’t make assumptions, AI doesn’t have content. _E.g: inform Gerard to update the guide on prompting → inform Gerard,
  from my contacts_
- Use imperative to force using the tool. _E.g: you must save to the database,_
- Provide a clear sequence of actions. _E.g: first generate an idea and then send it to client_
- Imagine and describe possible logical paths. _E.g: if you need more information, ask the user before sending a
  message_
- Provide example of formatting when needed. _E.g: data in a json format `{name:value email:value}`_

We are gonna keep updating this guide with more use cases and recommendations. Don’t hesitate to join our Discord for
more updates or contact us to discuss what you want to build

Happy exploration!
